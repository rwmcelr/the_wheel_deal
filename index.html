<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dinner Roulette!</title>
    <style>
      body {
        font-family: sans-serif;
        background-color: #f0f0f0;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 20px;
      }

      #wheel_container {
        position: relative;
        width: 400px;
        height: 400px;
        border-radius: 50%;
        overflow: hidden;
        background-color: #fff;
      }

      #wheel {
        display: block;
        border-radius: 50%;
      }

      #arrow {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -65%);
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 15px solid #333;
        z-index: 10;
      }

      #spin {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background-color: #333;
        color: #fff;
        border-radius: 50%;
        border: 2px solid black;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 20px;
        cursor: pointer;
        z-index: 10;
      }

      #controls {
        margin-top: 20px;
        text-align: center;
      }

      #editor input {
        width: 100%;
        margin: 0;
        box-sizing: border-box;
      }

      #editControls {
        display: none;
        margin-top: 10px;
      }

      select {
        padding: 5px;
        margin: 5px;
      }
    </style>
  </head>
  <body>
    <div id="wheel_container">
      <canvas id="wheel" width="400" height="400"></canvas>
      <div id="arrow"></div>
      <div id="spin">SPIN</div>
    </div>

    <div id="controls">
      <button id="editToggle">Edit</button>
      <div id="editControls">
        <label for="sliceCount">Slices: <span id="sliceCountLabel">7</span></label><br />
        <input type="range" id="sliceCount" min="2" max="12" value="7" />
        <br />
        <label for="paletteSelect">Color Palette:</label>
        <select id="paletteSelect"></select>
      </div>
      <button id="saveWheel">Save</button>
      <select id="loadWheelDropdown">
        <option value="">-- Load Saved Wheel --</option>
      </select>
    </div>

    <div id="editor"></div>

    <script>
      // =====================
      // Canvas & Wheel Setup
      // =====================
      const canvas = document.getElementById("wheel");
      const ctx = canvas.getContext("2d");
      const rad = canvas.width / 2;
      const TAU = 2 * Math.PI;

      // =====================
      // DOM Elements
      // =====================
      const spinButton = document.getElementById("spin");
      const sliceSlider = document.getElementById("sliceCount");
      const sliceLabel = document.getElementById("sliceCountLabel");
      const editToggle = document.getElementById("editToggle");
      const editControls = document.getElementById("editControls");
      const editorDiv = document.getElementById("editor");
      const saveButton = document.getElementById("saveWheel");
      const loadDropdown = document.getElementById("loadWheelDropdown");
      const paletteSelect = document.getElementById("paletteSelect");

      // =====================
      // Palette & Sector Data
      // =====================
      let arc;
      const paletteNames = ["Default", "Pastel Goth", "Woodsy"];
      let currentPalette = "Default";
      const palettes = {};
      let customLabels = {}; // Store custom labels permanently
      let sectors = [];

      // =====================
      // Spin Physics
      // =====================
      let ang = 0;
      let angVel = 0;
      let angVelMax = 0;
      const friction = 0.975;
      const angVelMin = 0.003;
      let isSpinning = false;
      let isAccelerating = false;
      let animFrame = null;

      // =====================
      // Palette Initialization
      // =====================
      function generatePalette(name) {
        const count = 16;
        switch (name) {
          case "Default":
            return [
              "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7",
              "#DDA0DD", "#98D8C8", "#F7DC6F", "#BB8FCE", "#85C1E9",
              "#F8C471", "#82E0AA", "#F1948A", "#85C1E9", "#D7BDE2", "#FAD7A0"
            ];
          case "Pastel Goth":
            return [
              "#F8BBD9", "#E1BEE7", "#C5CAE9", "#BBDEFB", "#C8E6C9",
              "#DCEDC8", "#E8E8E8", "#D3D3D3", "#C0C0C0", "#A9A9A9",
              "#FFCCBC", "#E8B4B8", "#D4A5A5", "#B8A9C9", "#A5B4FC", "#9CAF88"
            ];
          case "Woodsy":
            return [
              "#8B4513", "#654321", "#A0522D", "#CD853F", "#DEB887",
              "#8B7355", "#A0522D", "#D2691E", "#B8860B", "#8B6914",
              "#556B2F", "#6B8E23", "#228B22", "#32CD32", "#90EE90", "#98FB98"
            ];
          default:
            return [
              "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEAA7",
              "#DDA0DD", "#98D8C8", "#F7DC6F", "#BB8FCE", "#85C1E9",
              "#F8C471", "#82E0AA", "#F1948A", "#85C1E9", "#D7BDE2", "#FAD7A0"
            ];
        }
      }

      function generateDefaultSectors(count, palette) {
        return Array.from({ length: count }, (_, i) => ({
          color: palette[i % palette.length],
          label: customLabels[i] || `Slice ${i + 1}`
        }));
      }

      function initPalettes() {
        paletteNames.forEach(name => {
          palettes[name] = generatePalette(name);
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          paletteSelect.appendChild(opt);
        });
      }

      // =====================
      // Drawing Functions
      // =====================
      function drawSector(sector, i) {
        const startAngle = arc * i - Math.PI / 2;
        const endAngle = arc * (i + 1) - Math.PI / 2;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(rad, rad);
        ctx.arc(rad, rad, rad - 2, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = sector.color;
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#000';
        ctx.stroke();

        const textStartAngle = arc * i + ((arc * (i + 1) - arc * i) * 0.05);
        let labelLength = sector.label.length;
        let fontSize = labelLength <= 10 ? 20 : 18;
        while (!drawArcText(ctx, sector.label, textStartAngle, arc, rad, fontSize, currentPalette === "Pastel Goth") && fontSize > 10) {
          fontSize--;
        }
        ctx.restore();
      }

      function drawArcText(ctx, text, startAngle, arc, radius, fontSize, isPastelGoth) {
        ctx.save();
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.fillStyle = isPastelGoth ? "#333" : "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        let lines = [];
        let chars = Array.from(text);
        let charIndex = 0, baseRadius = rad * 0.85;
        const maxLines = Math.floor((baseRadius) / fontSize);
        for (let l = 0; l < maxLines - 2 && charIndex < chars.length; l++) {
          let r = baseRadius - l * fontSize;
          let effectiveArcLength = arc * r * 0.9;
          let lineChars = [];
          let lineWidth = 0;
          while (charIndex < chars.length) {
            let char = chars[charIndex];
            let charWidth = ctx.measureText(char).width;
            if (lineWidth + charWidth > effectiveArcLength) break;
            lineChars.push(char);
            lineWidth += charWidth;
            charIndex++;
          }
          lines.push({ text: lineChars.join(''), r: r });
        }
        if (charIndex < chars.length) {
          ctx.restore();
          return false;
        }

        for (let l = 0; l < lines.length; l++) {
          let { text, r } = lines[l];
          let charWidths = Array.from(text).map(char => ctx.measureText(char).width);
          let totalWidth = charWidths.reduce((a, b) => a + b, 0);
          let angularWidth = totalWidth / r;
          let angle = startAngle;
          for (let i = 0; i < text.length; i++) {
            let char = text[i];
            let charWidth = charWidths[i];
            let charAngle = charWidth / r;
            ctx.save();
            ctx.translate(rad, rad);
            ctx.rotate(angle + charAngle / 2);
            ctx.translate(0, -r);
            ctx.fillText(char, 0, 0);
            ctx.restore();
            angle += charAngle;
          }
        }
        ctx.restore();
        return true;
      }

      function drawWheel() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        arc = TAU / sectors.length;
        sectors.forEach(drawSector);
        rotate();
      }

      function rotate() {
        const index = getSectorIndex();
        const sector = sectors[index];
        canvas.style.transform = `rotate(${ang - Math.PI / 2}rad)`;
        spinButton.textContent = angVel ? "" : "SPIN";
        spinButton.style.background = sector.color;
      }

      // =====================
      // Spin Logic
      // =====================
      function getSectorIndex() {
        const adjusted = (ang - Math.PI / 2 + TAU) % TAU;
        return Math.floor(sectors.length - adjusted / TAU * sectors.length) % sectors.length;
      }

      function spin() {
        if (isSpinning) return;
        isSpinning = true;
        isAccelerating = true;
        angVelMax = Math.random() * (0.25 - 0.18) + 0.18;
        spinButton.textContent = "SPINNING";
        spinButton.style.background = "#333";
        cancelAnimationFrame(animFrame);
        frame();
      }

      function frame() {
        if (!isSpinning) return;
        if (isAccelerating) {
          angVel += 0.01;
          if (angVel >= angVelMax) {
            isAccelerating = false;
            angVel = angVelMax;
          }
        } else {
          angVel *= friction;
          if (angVel < angVelMin) {
            isSpinning = false;
            angVel = 0;
            cancelAnimationFrame(animFrame);
          }
        }
        ang += angVel;
        ang %= TAU;
        rotate();
        animFrame = requestAnimationFrame(frame);
      }

      // =====================
      // Editor & UI Logic
      // =====================
      function updateEditor() {
        editorDiv.innerHTML = "";
        sectors.forEach((sector, i) => {
          const input = document.createElement("input");
          input.type = "text";
          input.value = sector.label;
          input.addEventListener("input", e => {
            const newLabel = e.target.value;
            sector.label = newLabel;
            if (newLabel !== `Slice ${i + 1}`) {
              customLabels[i] = newLabel;
            } else {
              delete customLabels[i];
            }
            drawWheel();
          });
          editorDiv.appendChild(input);
        });
        editorDiv.style.display = "grid";
        editorDiv.style.gridTemplateColumns = "repeat(4, 1fr)";
        editorDiv.style.gap = "8px";
        editorDiv.style.width = "520px";
        editorDiv.style.boxSizing = "border-box";
        editorDiv.style.marginTop = "10px";
        editorDiv.style.justifyItems = "stretch";
      }

      function updateLoadDropdown() {
        loadDropdown.innerHTML = '<option value="">-- Load Saved Wheel --</option>';
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('wheel_')) {
            const name = key.replace('wheel_', '');
            const option = document.createElement('option');
            option.value = key;
            option.textContent = name;
            loadDropdown.appendChild(option);
          }
        }
      }

      // =====================
      // Event Listeners
      // =====================
      function handleEditToggle() {
        const isVisible = getComputedStyle(editControls).display !== "none";
        editControls.style.display = isVisible ? "none" : "block";
        editorDiv.style.display = isVisible ? "none" : "flex";
        if (!isVisible) {
          updateEditor();
        } else {
          document.getElementById('controls').appendChild(saveButton);
          document.getElementById('controls').appendChild(loadDropdown);
        }
      }

      function handleSliceSlider(e) {
        const count = parseInt(e.target.value);
        sliceLabel.textContent = count;
        const newSectors = [];
        for (let i = 0; i < count; i++) {
          if (i < sectors.length) {
            newSectors.push(sectors[i]);
          } else {
            newSectors.push({
              color: palettes[currentPalette][i % palettes[currentPalette].length],
              label: customLabels[i] || `Slice ${i + 1}`
            });
          }
        }
        sectors = newSectors;
        drawWheel();
        updateEditor();
      }

      function handlePaletteChange(e) {
        currentPalette = e.target.value;
        sectors = generateDefaultSectors(sectors.length, palettes[currentPalette]);
        drawWheel();
      }

      function handleSave() {
        const wheelData = {
          sectors: sectors,
          palette: currentPalette,
          sliceCount: sectors.length,
          customLabels: customLabels
        };
        const name = prompt("Enter a name for this wheel:");
        if (name) {
          localStorage.setItem(`wheel_${name}`, JSON.stringify(wheelData));
          updateLoadDropdown();
        }
      }

      function handleLoadDropdown(e) {
        if (e.target.value) {
          const wheelData = JSON.parse(localStorage.getItem(e.target.value));
          sectors = wheelData.sectors;
          currentPalette = wheelData.palette;
          customLabels = wheelData.customLabels || {};
          paletteSelect.value = currentPalette;
          sliceSlider.value = wheelData.sliceCount;
          sliceLabel.textContent = wheelData.sliceCount;
          drawWheel();
        }
      }

      // =====================
      // Initialization
      // =====================
      function initialize() {
        initPalettes();
        sectors = generateDefaultSectors(7, palettes[currentPalette]);
        drawWheel();
        updateLoadDropdown();
        // Attach event listeners
        editToggle.addEventListener("click", handleEditToggle);
        sliceSlider.addEventListener("input", handleSliceSlider);
        paletteSelect.addEventListener("change", handlePaletteChange);
        spinButton.addEventListener("click", spin);
        saveButton.addEventListener("click", handleSave);
        loadDropdown.addEventListener("change", handleLoadDropdown);
      }

      // Start the app
      initialize();
    </script>
  </body>
</html>